
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>18. Knapsack problems &#8212; OptimizationModels 0.8 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/tabs.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script>window.MathJax = "{'tex': { 'macros': {RR: '{\\bf R}', R: '{\\mathbb{R}}', bold: ['{\\bf #1}', 1] }, 'environments': {braced: ['\\left\\{', '\\right\\}'] }, 'inlineMath': [['$', '$'], ['\\(', '\\)']] } }"</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="22. Set covering, packing, partition" href="SetCovering.html" />
    <link rel="prev" title="17. Structured Mixed Integer Linear Optimization Models" href="StructuredMIPmodels.html" />
<link rel="stylesheet" type="text/css" 
     href="_static/custom.css" /> 


  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p class="hidden"><span class="math notranslate nohighlight">\(\newcommand{\R}{{\mathbb{R}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\Z}{{\mathbb{Z}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\N}{{\mathbb{N}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\var}[1]{{\color{red}{\mathbf{#1}}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\param}[1]{{\color{blue}{#1}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\mathsc}[1]{{\normalfont\textsc{#1}}}\)</span>
<span class="math notranslate nohighlight">\(\def\sc#1{\dosc#1\csod}\)</span>
<span class="math notranslate nohighlight">\(\def\dosc#1#2\csod{{\rm{#1{\rm\small #2}}}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\set}[1]{{\sc#1}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\mathvar}[1]{\var{#1}}\)</span>
<span class="math notranslate nohighlight">\(\newcommand{\half}{{\small{\frac{1}{2}}}}\)</span></p>
<section id="knapsack-problems">
<h1><span class="section-number">18. </span>Knapsack problems<a class="headerlink" href="#knapsack-problems" title="Permalink to this headline">¶</a></h1>
<p>One of the “simplest” integer linear optimization  models
is the so-called <span class="target" id="index-0"></span>knapsack problem. Assume we are  given a
set of <span class="math notranslate nohighlight">\(n\)</span>
“objects” and that to each of these both a “value”  and a
“weight” are associated. Assume also that a finite capacity, a non
negative real number, is given.
The problem then becomes to select a
subset of objects whose total weight does not exceed capacity. Among
these sets of objects, it is required to find one with maximal total
value.</p>
<p>Denoting by <span class="math notranslate nohighlight">\(\param{v}_{j}\)</span> the value of the <span class="math notranslate nohighlight">\(j\)</span>-th
object, with <span class="math notranslate nohighlight">\(\param{w}_{j}\)</span> its weight and
with <span class="math notranslate nohighlight">\(b\)</span> the capacity,
introducing a binary variable
associated with each object,  the following model is obtained:</p>
<div class="math notranslate nohighlight">
\begin{align*}
\max \sum_{j = 1}^{n} \param{v}_{j} \mathvar{\delta}_{j} &amp; \\
\sum_{j = 1}^{n} \param{w}_{j} \mathvar{\delta}_{j} &amp; \leq \param{b} \\
\mathvar{\delta}_{j} &amp; \in \{0,1 \} &amp; j \in 1,n
\end{align*}</div><p>This model is very basic, but  application of
some interest exist, although the main interest in this model consists  in the fact that
its  constraints are often found in other, more complex, models.</p>
<p>To describe possible applications, we start from
the name of the model. The idea is that a knapsack is available, which
can carry at most a certain capacity (which might be weight, volume,
number of elementary pallets, …). A set of objects is available, the
choice of each of which “consumes” part of the available capacity. The
problem consists then in filling the knapsack with the most valuable
collection of objects. It must be said that this application is just
used for teaching purposes, and nobody would ever prepare a knapsack this way.
However, if we slightly change the context, some direct applications
come to mind. As an example, the knapsack might be a truck, or a
container; the objects might be parcels to be delivered. The value is
a measure of the priority or of the urgency of delivery.</p>
<p>In other contexts, objects might be projects to be chosen. A company
might have a number of possible projects to perform, each of which
requires some budget in order to be completed. The budget is the
weight associated to each project and the capacity is the overall
budget available. The value of each project is the revenue associated
to project delivery.  Slightly changing the application, instead of a
monetary budget, we might have an overall time budget, and different
projects will have different time consumption and different gains
associated.
A similar application arises in advertising: there are a number of
available slots for placing a TV advertisement. Each slot is sold from
the TV company, and this is the “weight” of the object. The available
budget for this marketing operation is the capacity. The value
associated to each slot might be the (expected) audience, i.e., the
expected number of people who will see the advertisement.</p>
<p>This model is called <span class="target" id="index-1"></span>binary knapsack, as, for any object, the
decision to be taken is whether to choose or not each single
object. It would be trivial to
extend the model to cover the case in which some objects are available
in multiple copies, changing  binary variables into
non negative integer ones, with an upper bound equal to the number of
available objects.</p>
<p>The basic knapsack  model is only apparently a
simple one, with a single constraint (apart from binary constraints).
In integer optimization, the number of constraints or
variables is in general not an indicator of the complexity of a
problem.
Indeed, often, the reverse is true, with more efficient models
characterized by formulations with a huge number of constraints.</p>
<section id="advanced-modeling-cover-inequalities">
<h2><span class="section-number">18.1. </span>Advanced modeling: cover inequalities<a class="headerlink" href="#advanced-modeling-cover-inequalities" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Although the purpose of this part is to introduce modeling
techniques,
some algorithmic aspects need to be addressed too, as, for difficult
integer optimization problems, the possibility of finding an optimal  solution
is connected with the goodness of the formulation, something which  goes beyond
the purely formal correctness. That is, there might be  different
correct formulations of the same problem, all corrected from the point of view
of modeling, but  different from the point
of view of their closedness to the ideal representation. Within
integer optimization, the boundary between models and algorithms is quite
vague.</p>
<p>There exist many heuristics for the approximate resolution of
knapsack problems; moreover, the simple structure
of the constraints makes the solution of the linear relaxation
particularly simple. In fact, the optimal solution of the
linear relaxation is obtained by first sorting the objects in  non-increasing order
with respect to the ratio between  value and weight. Scanning this
list, if an object fits the knapsack, it is chosen (its binary
variable is set to 1). As soon as a  first object is found which
cannot be included in the solution, the corresponding variable is set
to the fraction of the object
necessary to “saturate” the capacity constraint.</p>
<div class="math notranslate nohighlight">
\begin{align*}
\bar{\jmath} &amp;:= \arg \max \{i: \sum_{j=1}^{i} \param{w}_{i} \leq b
\} \\
\mathvar{\delta}_j &amp; = 1 &amp; \forall \, j \leq \bar{\jmath} \\
\mathvar{\delta}_{\bar{\jmath}+1} &amp; = \frac{b -
\sum_{i=1}^{\bar{\jmath}} \param{w}_j}{\param{w}_{\bar{\jmath}+1}}  \\
\mathvar{\delta}_j &amp; = 0 &amp; \textrm{ otherwise}
\end{align*}</div><p>A simple implementation of the basic model is given:</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" role="tablist"><button aria-controls="panel-0-QU1QTA==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-0-QU1QTA==" name="QU1QTA==" role="tab" tabindex="0">AMPL</button><button aria-controls="panel-0-SnVsaWE=" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-0-SnVsaWE=" name="SnVsaWE=" role="tab" tabindex="-1">Julia</button></div><div aria-labelledby="tab-0-QU1QTA==" class="sphinx-tabs-panel group-tab" id="panel-0-QU1QTA==" name="QU1QTA==" role="tabpanel" tabindex="0"><div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text">Knapsack.mod</span><a class="headerlink" href="#id2" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">OBJECTS</span><span class="p">;</span>
<span class="n">param</span> <span class="n">weight</span><span class="p">{</span><span class="n">OBJECTS</span><span class="p">};</span>
<span class="n">param</span> <span class="n">value</span><span class="p">{</span><span class="n">OBJECTS</span><span class="p">};</span>
<span class="n">param</span> <span class="n">cap</span><span class="p">;</span>

<span class="n">var</span> <span class="n">delta</span><span class="p">{</span><span class="n">OBJECTS</span><span class="p">},</span> <span class="n">binary</span><span class="p">;</span>

<span class="n">maximize</span> <span class="n">total_value</span><span class="p">:</span> <span class="nb">sum</span> <span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="n">OBJECTS</span><span class="p">}</span> <span class="n">value</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

<span class="n">s</span><span class="o">.</span><span class="n">t</span><span class="o">.</span> <span class="n">knapsack</span><span class="p">:</span>
   <span class="nb">sum</span><span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="n">OBJECTS</span><span class="p">}</span> <span class="n">weight</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cap</span><span class="p">;</span> 
</pre></div>
</div>
</div>
</div><div aria-labelledby="tab-0-SnVsaWE=" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-0-SnVsaWE=" name="SnVsaWE=" role="tabpanel" tabindex="0"><div class="literal-block-wrapper docutils container" id="id3">
<div class="code-block-caption"><span class="caption-text">Knapsack.jl</span><a class="headerlink" href="#id3" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># to be done</span>
</pre></div>
</div>
</div>
</div></div>
<p>while the following is a tiny numerical example:</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" role="tablist"><button aria-controls="panel-1-QU1QTA==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-1-QU1QTA==" name="QU1QTA==" role="tab" tabindex="0">AMPL</button><button aria-controls="panel-1-SnVsaWE=" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-1-SnVsaWE=" name="SnVsaWE=" role="tab" tabindex="-1">Julia</button></div><div aria-labelledby="tab-1-QU1QTA==" class="sphinx-tabs-panel group-tab" id="panel-1-QU1QTA==" name="QU1QTA==" role="tabpanel" tabindex="0"><div class="literal-block-wrapper docutils container" id="id4">
<div class="code-block-caption"><span class="caption-text">Knapsack.dat</span><a class="headerlink" href="#id4" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">OBJECTS</span> <span class="o">:=</span> <span class="n">A</span> <span class="n">B</span> <span class="n">C</span> <span class="n">D</span> <span class="n">E</span> <span class="n">F</span> <span class="n">G</span> <span class="n">H</span> <span class="n">I</span> <span class="n">J</span> <span class="n">K</span> <span class="n">L</span> <span class="n">M</span> <span class="n">N</span> <span class="n">O</span><span class="p">;</span>

<span class="n">param</span><span class="p">:</span> 
  <span class="n">value</span> <span class="n">weight</span><span class="o">:=</span>
<span class="n">A</span> <span class="mi">135</span>     <span class="mi">70</span>    
<span class="n">B</span> <span class="mi">139</span>     <span class="mi">73</span>    
<span class="n">C</span> <span class="mi">149</span>     <span class="mi">77</span>    
<span class="n">D</span> <span class="mi">150</span>     <span class="mi">80</span>    
<span class="n">E</span> <span class="mi">156</span>     <span class="mi">82</span>    
<span class="n">F</span> <span class="mi">163</span>     <span class="mi">87</span>    
<span class="n">G</span> <span class="mi">173</span>     <span class="mi">90</span>    
<span class="n">H</span> <span class="mi">184</span>     <span class="mi">94</span>    
<span class="n">I</span> <span class="mi">192</span>     <span class="mi">98</span>    
<span class="n">J</span> <span class="mi">201</span>    <span class="mi">106</span>    
<span class="n">K</span> <span class="mi">210</span>    <span class="mi">110</span>    
<span class="n">L</span> <span class="mi">214</span>    <span class="mi">113</span>    
<span class="n">M</span> <span class="mi">221</span>    <span class="mi">115</span>    
<span class="n">N</span> <span class="mi">229</span>    <span class="mi">118</span>    
<span class="n">O</span> <span class="mi">240</span>    <span class="mi">120</span>    
<span class="p">;</span>

<span class="n">param</span> <span class="n">cap</span> <span class="o">:=</span> <span class="mi">730</span><span class="p">;</span>

</pre></div>
</div>
</div>
</div><div aria-labelledby="tab-1-SnVsaWE=" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-1-SnVsaWE=" name="SnVsaWE=" role="tabpanel" tabindex="0"><div class="literal-block-wrapper docutils container" id="id5">
<div class="code-block-caption"><span class="caption-text">Knapsack.dat</span><a class="headerlink" href="#id5" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># to be done</span>
</pre></div>
</div>
</div>
</div></div>
<p>Solving the model, given its very small size, is indeed very easy. A
solver like, e.g., CBC, in a fraction of a second, and 24 Branch and
Bound iterations, returns the optimal solution consisting in choosing
objects A, B, C, D, H, I, N, O, with total weight 730 ( full capacity)
and total profit 1418. The relaxed solution has objects
A, C, G, H, I, N, O fully in the knapsack, while object M is chosen at
54.78% level. The optimal value of the relaxed problem is 1423.07,
from which we see that the gap between the optimal and the relaxed
solution is relatively small (0.36%).</p>
<p>We can already see from this tiny example that the integer solution is not
a rounding of the solution of the linear relaxation;</p>
<p>Many of the most recent
integer linear optimization approaches require a reformulation of the
problem using additional constraints whose purpose is,
mainly, to improve the value of the linear relaxation,
decreasing the gap between the optimal solution and the relaxed one.
Inserting additional constraints without eliminating any
feasible solution leads to a smaller polyhedron in the relaxation and,
as a consequence, to a possible improvement in the value of the relaxed problem.
There exist no general and efficient technique to define
these additional constraints, and specific classes need to be devised
for each specific class of problems.
Finding classes of these inequalities is, thus, in a certain sense a
modeling problem, albeit
different from those encountered so far.</p>
<p>For the binary backpack problem, a few simple arguments
allow us to deduce some valid constraints for the problem which are in
general not valid for the  linear relaxation. The
family of <em>covering inequalities</em> can be deduced
from the trivial observation that if <span class="math notranslate nohighlight">\(k\)</span> items
have a total weight greater than the capacity,
then no more than <span class="math notranslate nohighlight">\(k-1\)</span> of them can belong to a feasible solution.
In formulas, if <span class="math notranslate nohighlight">\(S\)</span> is a subset of objects
such that</p>
<div class="math notranslate nohighlight">
\[
\sum_{j \in S} \param{w}_{j}&gt; \param{b}
\]</div><p>then the following inequality is valid</p>
<div class="math notranslate nohighlight">
\[
\sum_{j \in S} \mathvar{\delta}_{j} \leq |S| -1
\]</div><p>where <span class="math notranslate nohighlight">\(| S |\)</span> is the cardinality of the set <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p>An inequality like this one is not necessarily satisfied in the points of
linear relaxation polyhedron.
Adding all possible cover inequalities to the formulation
is not a feasible, in general, as their number can be huge; moreover,
many of these inequalities are redundant, as they are dominated by
others of the same family. An improvement
on this family of inequalities  corresponds to
considering only <em>minimal</em> sets,  with respect to the property of
be a cover (that is, to contain objects that exceed the
capacity of the container).</p>
<p>Let us consider a simpler numerical example, to outline the basic idea
of adding cover inequalities. Consider a knapsack problem with the
following objects:</p>
<div class="math notranslate nohighlight">
\begin{align*}
\begin{array}{ccccccc|c}
A &amp; B &amp; C &amp; D &amp; E &amp; F &amp; G &amp; cap \\
11 &amp; 6 &amp; 6 &amp; 5 &amp; 5 &amp; 4 &amp; 1 &amp; 19
\end{array}
\end{align*}</div><p>We do not write the objective function as our purpose here is just to
show how to improve the formulation, i.e., how to add valid
inequalities. In a real situation, however, a procedure, called
<em>separation</em> should be defined which, given the solution of a
relaxation of the problem, finds at least one cut inequality, i.e., a
valid inequalities which makes the current solution of the relaxed
problem infeasible. Adding such a cut would lead to an improvement in
the relaxation and to finding a different solution of the relaxed
problem.</p>
<p>Consider objects A, B, C: their total weight is 23, thus they can be
used to form a cover inequality:</p>
<div class="math notranslate nohighlight">
\begin{align*}
\mathvar{\delta}_A + \mathvar{\delta}_B + \mathvar{\delta}_C &amp; \leq 2
\end{align*}</div><p>If we consider, e.g., C, D, E, F, G, their total weight is 21, so we
might define a cover inequality form these objects, with right hand
side 4 (no more than 4 of these 5 can be in any knapsack). However,
the objects still form a cover if we cancel object G, the lightest
one. So the inequality</p>
<div class="math notranslate nohighlight">
\begin{align*}
\mathvar{\delta}_C + \mathvar{\delta}_D + \mathvar{\delta}_E +
\mathvar{\delta}_F &amp; \leq 3
\end{align*}</div><p>is a valid cover inequality and it dominates the one obtained
including object G.</p>
<p>Another observation is worth at this point: if at most 3 out of the
set of objects <span class="math notranslate nohighlight">\(C,D,E,F\)</span> can be inserted in a feasible
knapsack, it is clear that, including in the set also objects
<span class="math notranslate nohighlight">\(A,B\)</span>, whose weight is even larger, will not lead to the
possibility of inserting more than 3 objects. It is thus true that the
following inequality</p>
<div class="math notranslate nohighlight">
\begin{align*}
\mathvar{\delta}_A + \mathvar{\delta}_B + \mathvar{\delta}_C +
\mathvar{\delta}_D + \mathvar{\delta}_E +
\mathvar{\delta}_F &amp; \leq 3
\end{align*}</div><p>is also valid. Moreover, it is stronger that the cover inequality
associated to that set, since it would require a right hand side
equal to 5. This kind of inequality is called an <span class="target" id="index-2"></span>extension
inequality. In general, given a cover associated to a subset of
objects <span class="math notranslate nohighlight">\(S\)</span>, and extended cover inequality is given by</p>
<div class="math notranslate nohighlight">
\begin{align*}
\sum_{j \in S} \mathvar{\delta}_j + \sum_{j \not\in S : \param{w}_j \geq
\param{w}_k \forall\,k \in S}  \mathvar{\delta}_j &amp; \leq |S| -1
\end{align*}</div><p>It can be recalled here that these inequalities, i.e.,
non-dominated cover inequalities and extended cover inequalities,
are already a potentially large family of valid inequalities;
however, although large, this set of inequalities is not sufficient
to fully describe the ideal polyhedron for the binary knapsack
problem. Other inequalities, in particular those known as
<span class="target" id="index-3"></span>lifted inequalities can be defined and added to the
set. We refer the interested reader to the vast literature on this
subject, starting, e.g., by <span id="id1">[<a class="reference internal" href="Bibliography.html#id15"><span>18</span></a>]</span>.
In any case, for moderate to large size problem instances,
generating and adding all these inequalities to the formulation is
usually out of question. What can be done is to solve a relaxation
of the problem, to design a procedure
to separate the solution of the relaxation, if not feasible; and
then to add this inequality to the formulation, solve again and
repeat the loop. Recall however that separation, i.e., finding a
violated inequality within the family of cover and lifted
inequalities, is as hard as solving the problem from scratch and,
in general, heuristic separation methods are used. These methods
can often generate a valid inequality which cuts off the current
solution, but, sometimes, cannot find one even if it exists.</p>
<p>The emphasis we have given to this advanced topic here is connected
to the fact that the importance of knapsack valid inequalities goes
far beyond the problem itself. In fact, given any inequality with
binary constraints, it can be seen as a knapsack inequality,
possibly after a few variable substitutions.
Consider, as an example the inequality</p>
<div class="math notranslate nohighlight">
\begin{align*}
3 \mathvar{\delta}_1 - 5 \mathvar{\delta}_2 +2
\mathvar{\delta}_3 -2\mathvar{\delta}_4 &amp; \leq 1
\end{align*}</div><p>If we replace the variables with a  negative coefficient with their
complement to 1, we obtain</p>
<div class="math notranslate nohighlight">
\begin{align*}
3 \mathvar{\delta}_1 - 5 (1- \mathvar{\bar{\delta}}_ 2) +2
\mathvar{\delta}_3 -2 (1- \mathvar{\bar{\delta}}_ 4) &amp; \leq 1
\end{align*}</div><p>which simplifies to</p>
<div class="math notranslate nohighlight">
\begin{align*}
3 \mathvar{\delta}_1 + 5 \mathvar{\bar{\delta}}_ 2 +2
\mathvar{\delta}_3 +2 \mathvar{\bar{\delta}}_ 4 &amp; \leq 8
\end{align*}</div><p>and this is exactly  a binary knapsack constraint. We can, thus, add
cover inequalities and their generalizations in order to strengthen the
formulation. A  similar technique can be applied in the case
of  <span class="math notranslate nohighlight">\(\geq\)</span> constraints; thus  any inequality constraint
in binary variables is equivalent to a knapsack inequality
and, therefore, can be strengthened through the techniques seen
in this paragraph. This is indeed done by most of the advanced
exact mixed integer optimization solvers available.</p>
</div></blockquote>
</section>
</section>
<section id="multiple-knapsack-models-bin-packing-cutting-stock">
<h1><span class="section-number">19. </span>Multiple knapsack models, Bin Packing, Cutting Stock<a class="headerlink" href="#multiple-knapsack-models-bin-packing-cutting-stock" title="Permalink to this headline">¶</a></h1>
<p>The knapsack model can be easily generalized to the case of multiple knapsacks
(or multiple containers). The problem may still be that of choosing
the maximum  “value” of the selected objects, with constraints
imposing not to exceed a  capacity in each of the available containers.
The “natural” formulation  of the problem is quite immediate, after we
have presented the binary knapsack problem. However an important
difference characterizes these models. Now the decision to be taken is
not just whether an object is to be chosen or not: now, if an object
is chosen, we need to decide also to which container will the object
be allocated. We can obtain this result by using two indices for each
binary variable, one associated to each object,
the other one  associated to each container. Let
<span class="math notranslate nohighlight">\(\mathvar{\delta}_{ij}\)</span> be a binary variable with value 1 if and only
if the object <span class="math notranslate nohighlight">\(j\)</span>  is placed in
container <span class="math notranslate nohighlight">\(i\)</span>. With this choice of variables, the  formulation
closely follows that
of the standard knapsack;  the main variants are the presence of a
capacity constraint for each container  and a constraint which forbids
the same object to be associated to more than one container.</p>
<p>Let us denote by
<span class="math notranslate nohighlight">\(n\)</span>, as before, the number of objects and by <span class="math notranslate nohighlight">\(C\)</span> the
number of containers, each of which characterized by a finite capacity
<span class="math notranslate nohighlight">\(\param{c}_i\)</span>.
A model for this problem might be written as follows:</p>
<div class="math notranslate nohighlight">
\begin{align*}
\max_{\mathvar{\delta}}  \sum_{j=1}^n \param{v}_j \sum_{i=1}^C
\mathvar{\delta}_{ij} &amp; \\
\sum_{i=1}^C \mathvar{\delta}_{ij} &amp; \leq 1 &amp; \forall\,j=1,\ldots,n \\
\sum_{j=1}^n \param{w}_j \mathvar{\delta}_{ij} &amp; \leq \param{b}_i &amp;
\forall\,i=1,\ldots,C \\
\mathvar{\delta}_{ij} &amp; \in \{0,1\}  &amp; \forall\,i,j
\end{align*}</div><p>The first group of inequalities state that each object can be placed
<em>at most</em> in a single container, once. The second group is composed of
knapsack constraints, one for each container, each of which
characterized by a maximum capacity.
It is worth observing that these knapsack inequalities might also be
generalized to cope with different capacities for each
container. Consider, as an example, loading a group of trucks, taking
into account both the weight as well as the volume required and
available. Then, for each truck, two knapsack inequalities can be
imposed, one for the total weight, and another one for the total
volume. Of course volume computation is especially hard, if this
depends on how the parcels are loaded in the three-dimensional
available space. However, in many cases, the actual loading pattern
might be disregarded, and a total volume occupancy can be simply
computed. This is the case, e.g., for goods delivered in pallets: the
volume occupied by a pallet depends only on the base surface, as all
of the vertical space above the pallet is unavailable for loading. It
remains the problem of deciding a two-dimensional arrangement, but
pallets are standard and efficient loading patterns can be decided a
priori.</p>
<p>A classical application of this model, apart from the natural one in
transport logistics, is  related to one dimensional <span class="target" id="index-4"></span>cutting
stock problems:
given a set of one-dimensional objects (for example cables)
and a set of purchase orders, defined as length of cable to be cut for
a customer, a problem might be that of deciding which order to satisfy
and from which of the available cables to cut it, in order to maximize
a total value, which, in some cases, is a measure of the priority of
each order.</p>
<p>In the following we report an example of implementation of a tiny
example for the cutting stock problem:</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" role="tablist"><button aria-controls="panel-2-QU1QTA==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-2-QU1QTA==" name="QU1QTA==" role="tab" tabindex="0">AMPL</button><button aria-controls="panel-2-SnVsaWE=" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-2-SnVsaWE=" name="SnVsaWE=" role="tab" tabindex="-1">Julia</button></div><div aria-labelledby="tab-2-QU1QTA==" class="sphinx-tabs-panel group-tab" id="panel-2-QU1QTA==" name="QU1QTA==" role="tabpanel" tabindex="0"><div class="literal-block-wrapper docutils container" id="id6">
<div class="code-block-caption"><span class="caption-text">cutstock.mod</span><a class="headerlink" href="#id6" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span> <span class="n">OBJECTS</span><span class="p">;</span>
<span class="nb">set</span> <span class="n">CONTAINERS</span><span class="p">;</span>

<span class="n">param</span> <span class="n">weight</span><span class="p">{</span><span class="n">OBJECTS</span><span class="p">};</span>
<span class="n">param</span> <span class="n">value</span><span class="p">{</span><span class="n">OBJECTS</span><span class="p">};</span>
<span class="n">param</span> <span class="n">capacity</span><span class="p">{</span><span class="n">CONTAINERS</span><span class="p">};</span>

<span class="n">var</span> <span class="n">delta</span><span class="p">{</span><span class="n">CONTAINERS</span><span class="p">,</span> <span class="n">OBJECTS</span><span class="p">},</span> <span class="n">binary</span><span class="p">;</span>

<span class="n">maximize</span> <span class="n">total_value</span><span class="p">:</span>
   <span class="nb">sum</span> <span class="p">{</span><span class="n">i</span> <span class="ow">in</span> <span class="n">CONTAINERS</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">OBJECTS</span><span class="p">}</span> <span class="n">value</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">];</span>
   
<span class="n">s</span><span class="o">.</span><span class="n">t</span><span class="o">.</span> <span class="n">OneAtMost</span><span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="n">OBJECTS</span><span class="p">}:</span>
  <span class="nb">sum</span><span class="p">{</span><span class="n">i</span> <span class="ow">in</span> <span class="n">CONTAINERS</span><span class="p">}</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">s</span><span class="o">.</span><span class="n">t</span><span class="o">.</span> <span class="n">CapacityConstraints</span><span class="p">{</span><span class="n">i</span> <span class="ow">in</span> <span class="n">CONTAINERS</span><span class="p">}:</span>
   <span class="nb">sum</span><span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="n">OBJECTS</span><span class="p">}</span> <span class="n">weight</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">capacity</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
   
</pre></div>
</div>
</div>
</div><div aria-labelledby="tab-2-SnVsaWE=" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-2-SnVsaWE=" name="SnVsaWE=" role="tabpanel" tabindex="0"><div class="literal-block-wrapper docutils container" id="id7">
<div class="code-block-caption"><span class="caption-text">cutstock.jl</span><a class="headerlink" href="#id7" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># to be done</span>
</pre></div>
</div>
</div>
</div></div>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" role="tablist"><button aria-controls="panel-3-QU1QTA==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-3-QU1QTA==" name="QU1QTA==" role="tab" tabindex="0">AMPL</button><button aria-controls="panel-3-SnVsaWE=" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-3-SnVsaWE=" name="SnVsaWE=" role="tab" tabindex="-1">Julia</button></div><div aria-labelledby="tab-3-QU1QTA==" class="sphinx-tabs-panel group-tab" id="panel-3-QU1QTA==" name="QU1QTA==" role="tabpanel" tabindex="0"><div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-text">cutstock.dat</span><a class="headerlink" href="#id8" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">param</span><span class="p">:</span> <span class="n">OBJECTS</span><span class="p">:</span> <span class="n">weight</span> <span class="n">value</span><span class="o">:=</span>
<span class="n">A</span> <span class="mi">20</span>  <span class="mi">10</span>
<span class="n">B</span> <span class="mi">18</span>   <span class="mi">5</span>
<span class="n">C</span> <span class="mi">17</span>   <span class="mi">7</span>
<span class="n">D</span> <span class="mi">15</span>   <span class="mi">6</span>
<span class="n">E</span> <span class="mi">14</span>   <span class="mi">9</span>
<span class="n">F</span> <span class="mi">12</span>  <span class="mi">10</span>
<span class="n">G</span> <span class="mi">10</span>  <span class="mi">12</span>
<span class="n">H</span> <span class="mi">5</span>    <span class="mi">4</span>
<span class="n">I</span> <span class="mi">4</span>    <span class="mi">4</span>
<span class="n">J</span> <span class="mi">2</span>    <span class="mi">1</span>
<span class="p">;</span>

<span class="n">param</span><span class="p">:</span> <span class="n">CONTAINERS</span> <span class="p">:</span> <span class="n">capacity</span> <span class="o">:=</span>
<span class="n">C1</span> <span class="mi">35</span>
<span class="n">C2</span> <span class="mi">30</span>
<span class="n">C3</span> <span class="mi">28</span><span class="p">;</span>

</pre></div>
</div>
</div>
</div><div aria-labelledby="tab-3-SnVsaWE=" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-3-SnVsaWE=" name="SnVsaWE=" role="tabpanel" tabindex="0"><div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-text">cutstock.dat</span><a class="headerlink" href="#id9" title="Permalink to this code">¶</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># to be done</span>
</pre></div>
</div>
</div>
</div></div>
<p>In the example, we have three cables, whose length is 35, 30, 28,
respectively, and we wish to cut them in order to satisfy orders,
given in the data file, according to their required quantity and to
their value (priority).
Solved with a good branch and bound solver we obtain the optimal
solution  consisting in allocating orders A and D to cable 1 (using
its full capacity), orders E, F, I to cable 2 (again, used at full
capacity) and orders C, G to cable 3, using 27 out of 28 units. Orders
B, H , J could not be satisfied.</p>
</section>
<section id="bin-packing-container-optimization">
<h1><span class="section-number">20. </span>Bin packing -  container optimization<a class="headerlink" href="#bin-packing-container-optimization" title="Permalink to this headline">¶</a></h1>
<p>Am important variant of the multiple knapsack model
consists in the optimization of the total number or total cost
of the containers needed to host all of the objects. The model
becomes more complex in this case. In fact it becomes necessary to add
a  variable for each container, whose value is 1 if and only if the
container is used. We define a
binary variable <span class="math notranslate nohighlight">\(\var{y}_i, i =1,C\)</span> and,
through suitable constraints, we should impose that this variable has
value 1 if and only if container <span class="math notranslate nohighlight">\(i\)</span> contains  at least
an object.
There are several ways to formulate this constraint, some of which
related to the formulation of logical constraints as we have seen in
chapter <a class="reference internal" href="MIPModels.html#using-binary-variables-in-logical-constraints"><span class="std std-ref">Using binary variables in logical constraints</span></a>. In fact the
link between object allocation and container usage
can be formulated as:</p>
<div class="math notranslate nohighlight">
\[
\exists \, j: \mathvar{\delta}_{ij} = 1 \implies \var{y}_i = 1
\]</div><p>or, equivalently,</p>
<div class="math notranslate nohighlight">
\[
\var{y}_i = 0 \implies  \mathvar{\delta}_{ij} = 0 \quad \forall \, j
\]</div><p>The opposite implication is not needed as, in general, to each
container a positive cost is associated, so that there is no incentive
to have the binary variable associated to a container have value 1
when no object is placed in that container.</p>
<p>Let <span class="math notranslate nohighlight">\(\param{c}_i\)</span> denote the cost of using
container <span class="math notranslate nohighlight">\(i\)</span>. If all costs are equal to one, the problem
becomes that of finding the minimum number of containers which are
sufficient to carry all of the required load. Otherwise the problem
consists in minimizing the cost of used containers.
The generic bin-packing problem can thus be formulated as</p>
<div class="math notranslate nohighlight">
\begin{align*}
\min_{\var{y}, \mathvar{\delta}}  \sum_{i=1}^C \param{c}_i
\var{y}_i \\
\sum_{i=1}^C \mathvar{\delta}_{ij} &amp; = 1 &amp; \forall\,j=1,\ldots,n \\
\exists \, j: \mathvar{\delta}_{ij} = 1 &amp; \implies \var{y}_i = 1 &amp;
\forall\,i=1,C \\
\sum_{j=1}^n \param{w}_j
\mathvar{\delta}_{ij} &amp; \leq \param{b}_i &amp;
\forall\,i=1,\ldots,C \\
\mathvar{\delta}_{ij} &amp; \in \{0,1\}  &amp; \forall\,i,j \\
\var{y}_i &amp; \in \{0,1\} &amp; \forall\, i
\end{align*}</div><p>A possible formulation of this implication is the following:
the statement <span class="math notranslate nohighlight">\(\mathvar{\delta} _ {ij} = 0 \, \forall \, j\)</span> can be
written as</p>
<div class="math notranslate nohighlight">
\[
\sum_{j=1}^n \mathvar{\delta}_{ij} \leq 0 \quad
\forall\,i =1,C
\]</div><p>or</p>
<div class="math notranslate nohighlight">
\begin{align*}
\var{y}_i = 0 &amp; \implies \sum_{j =1}^n
\mathvar{\delta}_{ij} \leq 0
\end{align*}</div><p>Recalling  modeling techniques with logical variables,
a redundant constraint needs to be imposed for the case in which the implicant
is false. Here if <span class="math notranslate nohighlight">\(\var{y}_i = 1\)</span>
an upper bound needs to be chosen for the right hand side. A simple
upper bound is given by the cardinality of the set of objects: in
fact, if a container is used, the total number of objects which might
be assigned to it is bounded by the total number of available objects.</p>
<div class="math notranslate nohighlight">
\begin{align*}
\sum_{j=1}^n \mathvar{\delta}_{ij} \leq \param{M}_i &amp;&amp; \forall \,
i =1,C
\end{align*}</div><p>where <span class="math notranslate nohighlight">\(\param{M}_i\)</span> can be chosen equal to
<span class="math notranslate nohighlight">\(n\)</span>. As an alternative, this constant might be
chosen equal to an upper bound on the number of objects which can be
assigned to the container taking into account their weight. If objects
are sorted in non decreasing order with respect to the weight, then we
might choose</p>
<div class="math notranslate nohighlight">
\begin{align*}
M_i &amp;= \max \{k : \sum_{j=1}^k \param{w}_j \leq \param{b}_i\}
\end{align*}</div><p>Given a correct upper bound, the logical constraint can be transformed
into a linear one:</p>
<div class="math notranslate nohighlight" id="equation-bpform1">
\begin{align*}
\sum_{j=1}^n \mathvar{\delta}_{ij} &amp;\leq \param{M}_i
\var{y}_i &amp; \forall \, i = 1,C
\end{align*}</div><p>There exist other correct  formulations for the same constraint.
The logical implication might also be
seen as equivalent to</p>
<div class="math notranslate nohighlight">
\begin{align*}
\var{y}_i = 0 &amp; \implies \mathvar{\delta}_{ij} = 0 &amp;  \forall \, i
= 1, C, j = 1, n
\end{align*}</div><p>This corresponds to the linear model</p>
<div class="math notranslate nohighlight" id="equation-bpform2">
\begin{align*}
\mathvar{\delta}_{ij} &amp;\leq \var{y}_i &amp; \forall \, i =1,C, j=1,n
\end{align*}</div><p>Finally another  modeling possibility consists in considering the
knapsack inequality and using the binary variable associated to the
container to switch the actual capacity between zero and the real
capacity, depending on the value of the binary variable.</p>
<div class="math notranslate nohighlight" id="equation-bpform3">
\begin{align*}
\sum_{j=1}^n \param{w}_{j} \mathvar{\delta}_{ij}
&amp;\leq \param{b}_{i} \var{y}_i &amp; \forall \, i = 1,C
\end{align*}</div><section id="comparison-between-the-formulations">
<h2><span class="section-number">20.1. </span>Comparison between the formulations<a class="headerlink" href="#comparison-between-the-formulations" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>Formulation  <a class="reference internal" href="#equation-bpform1">(1)</a> is weaker than
<a class="reference internal" href="#equation-bpform2">(2)</a>, at least when the upper bound chosen for
the logical implication is the total number of objects. In fact, to
see this, observe that if we sum all of the inequalities of
formulation <a class="reference internal" href="#equation-bpform2">(2)</a> we obtain the first formulation:</p>
<div class="math notranslate nohighlight">
\begin{align*}
\mathvar{\delta}_{ij} &amp; \leq \var{y}_i  &amp; \implies \\
\sum_{j=1}^n \mathvar{\delta}_{ij} &amp;\leq \sum_{j
=1}^n  \var{y}_i  \\
&amp; = n \var{y}_i
\end{align*}</div><p>This means that the polyhedron obtained by relaxing the binary
constraint on all variables in formulation <a class="reference internal" href="#equation-bpform2">(2)</a>
is contained in the polyhedron obtained from
<a class="reference internal" href="#equation-bpform1">(1)</a>.  Thus the second formulation is at least as
strong as the first one. In order to check whether it is strictly
stronger, and, thus, preferable from the point of view of the
quality of the relaxation, we need to exclude that the two
polyhedra are identical. But this is true as we can always find a
solution in the second polyhedron which does not belong to the
first one, provided that both the number of objects and the number
of containers are greater than one. As an example, let</p>
<div class="math notranslate nohighlight">
\begin{align*}
\mathvar{\delta}_{ij} &amp;= 0 &amp; \forall \, i \ne 1 \\
\mathvar{\delta}_{1j} &amp;= 1 \\
\var{y}_j &amp; =  1 / n
\end{align*}</div><p>This is an example of a solution which satisfies the constraints of
the second formulation, but violates some of the constraints in the
first one. Observe that, in order to show an example like this one,
we had to search among non binary solutions. In fact, both
formulations are correct, which means that they describe exactly
the same set of binary feasible solutions. If a difference exists
between the two formulation, this needs to be searched in the
relaxed, non binary, set of solutions.</p>
<p>For what concerns formulation  <a class="reference internal" href="#equation-bpform3">(3)</a>, this is
not directly comparable with the others: depending on  the values ​​
of the parameters, it could be
stronger, weaker, or even neither stronger nor weaker than the
other ones. This means that the relaxation of this formulation
might neither be contained nor containing any of the other two.
In this case, a possibility might be to use both formulation, in
order to strengthen the resulting model.</p>
<p>Here we have shown that the second formulation is stronger than the
first one. However, it contains many more constraints and thus,
for large problems,
the overhead due to the need to solve large linear optimization problems
might mitigate the advantages of a stronger formulation.
A possibility, for large problems,  could be
that of using the strongest formulation in an implicit, dynamic, way.
AS we have already seen, the idea is to avoid the explicit
insertion of  all of the constraints in the initial formulation, but
adding some of them, as needed and when needed.
We might  solve the problem without any constraint
linking logical variables associate to objects with those
associated to containers. Then we might insert
only those constraints of the  type <span class="math notranslate nohighlight">\(\mathvar{\delta}_{ij}
\leq \var{y}_i\)</span> that are violated in the
current solution. Solving the problem  obtained in this way
either  a feasible solution is obtained, in which case it will be
also  optimal for the original problem. Otherwise,  there must be
exist some violated constraint among those still
not included in the formulation. These constraints are added to the
formulation and the whole process is iterated.</p>
</div></blockquote>
<p>If in the general formulation of bin packing problems, a requirement prescribes
to choose exactly one copy of each item to be placed in one of the
containers (and only one). If we change the constraint to one of
allocating an integer number of copies, <span class="math notranslate nohighlight">\(\param{N}_j\)</span> of each
object, the problem remains quite similar in formulation, except that
the constraint now becomes</p>
<div class="math notranslate nohighlight">
\begin{align*}
\min_{\var{y}, \mathvar{\delta}}  \sum_{i=1}^C \param{c}_i
\var{y}_i \\
\sum_{i=1}^C \mathvar{\delta}_{ij} &amp; = \param{N}_j &amp; \forall\,j=1,\ldots,n \\
\exists \, j: \mathvar{\delta}_{ij} = 1 &amp; \implies \var{y}_i = 1 &amp;
\forall\,i=1,C \\
\sum_{j=1}^n \param{w}_j
\mathvar{\delta}_{ij} &amp; \leq \param{b}_i &amp;
\forall\,i=1,\ldots,C \\
\mathvar{\delta}_{ij} &amp; \in \{0,1\}  &amp; \forall\,i,j \\
\var{y}_i &amp; \in \{0,1\} &amp; \forall\, i
\end{align*}</div><p>This variant of the basic problem is often known as the
<span class="target" id="index-5"></span>Cutting stock model.</p>
<p>An application of bin-packing to a context different from that of
loading containers frequently found in logistics, or optimally cutting
parts from a minimum number of cables, is in the context of production
scheduling.
Here the containers are production machines, or plants, with their
maximum capacity (e.g., hours in a day); objects are jobs, with a
duration. If each machine has a cost, the problem becomes that of
scheduling all of the jobs so that the minimum (number or cost) of
necessary machines is found. A related problem is that of minimizing
the <span class="target" id="index-6"></span>makespan, i.e. the completion time of the last finishing
job. This problem can be easily modeled introducing an additional
variable, the makespan, which is greater or equal to the total sum of
used capacity in each machine (it is indeed a minimax problem).</p>
</section>
</section>
<section id="plant-location">
<h1><span class="section-number">21. </span>Plant location<a class="headerlink" href="#plant-location" title="Permalink to this headline">¶</a></h1>
<p>These problems arise in a quite different context, but share some
interesting modeling aspect with the models just presented. Assume
that a set of <span class="math notranslate nohighlight">\(n\)</span> customers, with a known demand for a product
are to be served by a set of plants, or inventories, whose location
has to be chosen based on cost considerations. A set of <span class="math notranslate nohighlight">\(C\)</span>
possible locations are known, and building a facility at location
<span class="math notranslate nohighlight">\(i\)</span> has a cost <span class="math notranslate nohighlight">\(\param{c}_i\)</span>. The (expected) demand
of each customer is <span class="math notranslate nohighlight">\(\param{w}_j\)</span> and the maximum capacity of
each location is <span class="math notranslate nohighlight">\(\param{b}_i\)</span>. Every customer chooses one of
the available facilities in order to satisfy all of the
demand. Another relevant information is the cost of connecting a
customer with a location: a quantity <span class="math notranslate nohighlight">\(\param{TC}_{ij}\)</span> is
given which represents the cost of serving customer <span class="math notranslate nohighlight">\(j\)</span> from
location <span class="math notranslate nohighlight">\(i\)</span> - this might be thought of as a transportation
cost. The overall model thus becomes:</p>
<div class="math notranslate nohighlight">
\begin{align*}
\min_{\var{y}, \mathvar{\delta}}  \sum_{i=1}^C \param{c}_i
\var{y}_i  + \sum_{i=1}^C \sum_{j=1}^n TC_{ij} \mathvar{\delta}_{ij} \\
\sum_{i=1}^C \mathvar{\delta}_{ij} &amp; = 1 &amp; \forall\,j=1,\ldots,n \\
\exists \, j: \mathvar{\delta}_{ij} = 1 &amp; \implies \var{y}_i = 1 &amp;
\forall\,i=1,C \\
\sum_{j=1}^n \param{w}_j
\mathvar{\delta}_{ij} &amp; \leq \param{b}_i &amp;
\forall\,i=1,\ldots,C \\
\mathvar{\delta}_{ij} &amp; \in \{0,1\}  &amp; \forall\,i,j \\
\var{y}_i &amp; \in \{0,1\} &amp; \forall\, i
\end{align*}</div><p>and the similarity with the bin-packing model is evident. Of course,
the logical implication should be modeled as a regular constraint, as
we have already seen.</p>
<p><a class="reference external" href="https://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="CreativeCommonsLicence" src="_images/Cc-by-nc-nd_icon.svg.png" /></a></p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="StructuredMIPmodels.html" title="previous chapter"><span class="section-number">17. </span>Structured Mixed Integer Linear Optimization Models</a></li>
      <li>Next: <a href="SetCovering.html" title="next chapter"><span class="section-number">22. </span>Set covering, packing, partition</a></li>
  </ul></li>
</ul>
</div>
<h3><a href="index.html">Table of Contents</a></h3>
<p class="caption"><span class="caption-text">Table of Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="OptimizationModels.html">1. Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="LinearModels.html">2. Linear Optimization Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="ProductMixProblems.html">3. Product Mix Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="BlendingModels.html">4. Blending Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="MultiPeriodModels.html">5. Multi Period Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="NetworkFlow.html">6. Network flow models</a></li>
<li class="toctree-l1"><a class="reference internal" href="ShortestPath.html">7. Shortest (Minimum Cost) Path Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="MaximumFlow.html">8. Maximum Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="Transportation.html">9. The transportation model</a></li>
<li class="toctree-l1"><a class="reference internal" href="Assignment.html">10. Assignment or bi-partite matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="Dynamic.html">11. Dynamic flows</a></li>
<li class="toctree-l1"><a class="reference internal" href="Objectives.html">12. Objectives and constraints in optimization models</a></li>
<li class="toctree-l1"><a class="reference internal" href="Objectives.html#some-nonlinear-problems-that-can-be-transformed-into-linear-ones">13. Some nonlinear problems that can be transformed into linear ones</a></li>
<li class="toctree-l1"><a class="reference internal" href="Constraints.html">14. Constraints in linear optimization models</a></li>
<li class="toctree-l1"><a class="reference internal" href="StochasticOptimization.html">15. Uncertainty modeling: Stochastic optimization models</a></li>
<li class="toctree-l1"><a class="reference internal" href="MIPModels.html">16. Mixed Integer Linear Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="StructuredMIPmodels.html">17. Structured Mixed Integer Linear Optimization Models</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">18. Knapsack problems</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#advanced-modeling-cover-inequalities">18.1. Advanced modeling: cover inequalities</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#multiple-knapsack-models-bin-packing-cutting-stock">19. Multiple knapsack models, Bin Packing, Cutting Stock</a></li>
<li class="toctree-l1"><a class="reference internal" href="#bin-packing-container-optimization">20. Bin packing -  container optimization</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#comparison-between-the-formulations">20.1. Comparison between the formulations</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#plant-location">21. Plant location</a></li>
<li class="toctree-l1"><a class="reference internal" href="SetCovering.html">22. Set covering, packing, partition</a></li>
<li class="toctree-l1"><a class="reference internal" href="TravelingSalesPerson.html">23. Sequencing problems: the Traveling Salesperson Problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="Quadratic.html">24. Quadratic Optimization Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">25. To do</a></li>
<li class="toctree-l1"><a class="reference internal" href="Bibliography.html">26. Bibliographic References</a></li>
<li class="toctree-l1"><a class="reference internal" href="Version.html">27. Version history</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Knapsack.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Fabio Schoen,  Creative Commons Cc-by-nc-nd.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/Knapsack.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>